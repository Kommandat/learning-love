-- AUTHOR: Lakshay Akula
Class = require "hump.class"

-- Load some default values for our rectangle.
function love.load() 

    -- set 1 m to 64 px
    love.physics.setMeter(64) 
    -- create world with vertical gravity of 0
    gravity = 0
    world = love.physics.newWorld(0, gravity*64, true)
    world:setCallbacks(beginContact, endContact, preSolve, postSolve)

    --  Size constants
    windowWidth  = 650
    windowHeight = 650
    border = 25
    sideLength = 100

    -- A table to hold all of our game objects
    objects = {}

    -- Creating the border
    initBorder()

    -- Creating the player
    initPlayer()

    -- Create a table of enemies
    objects.enemies = {}
    enemyNum = 0
    -- Add enemy to enemies
    addEnemy()
    addEnemy()
    
    --initial graphics setup
    love.graphics.setBackgroundColor(104, 136, 248) --set the background color to a nice blue
    love.window.setMode(650, 650) --set the window dimensions to 650 by 650 with no fullscreen, vsync on, and no antialiasing

    -- These tables contain things to delete
    remFixtures = {}

end

function love.update(dt)
    world:update(dt) --this puts the world into motion
 
  --here we are going to create some keyboard events
  if love.keyboard.isDown("right") then --press the right arrow key to push the ball to the right
    objects.player.body:applyForce(400, 0)
  elseif love.keyboard.isDown("left") then --press the left arrow key to push the ball to the left
    objects.player.body:applyForce(-400, 0)
  elseif love.keyboard.isDown("up") then --press the up arrow key to set the ball in the air
    objects.player.body:applyForce(0, -400)
  elseif love.keyboard.isDown("down") then 
    objects.player.body:applyForce(0, 400)
  elseif love.keyboard.isDown("r") then
    objects.player.body:setPosition(650/2, 650/2)
    objects.player.body:setLinearVelocity(0, 0) --we must set the velocity to zero to prevent a potentially large velocity generated by the change in position
    objects.player.body:setAngularVelocity(0)
  end

    cleanUp()
end

function love.draw()

    -- TODO
    for key,component in ipairs(objects.border) do
        love.graphics.setColor(72, 160, 14)
        love.graphics.polygon("fill", component.body:getWorldPoints(component.shape:getPoints()))
    end

    for key,triangle in ipairs(objects.player.triangles) do
        love.graphics.setColor(triangle.color)
        love.graphics.polygon("fill", objects.player.body:getWorldPoints(triangle.shape:getPoints())) 
    end

    for key,enemy in ipairs(objects.enemies) do
        for key,triangle in ipairs(enemy.triangles) do
            love.graphics.setColor(triangle.color)
            love.graphics.polygon("fill", enemy.body:getWorldPoints(triangle.shape:getPoints())) 
        end
    end
end

function initBorder()
    objects.border = {}

    -- First ground and ceiling
    objects.border.ground = {}
    objects.border.ground.body = love.physics.newBody(world, windowWidth/2, windowHeight-border/2) --remember, the shape (the rectangle we create next) anchors to the body from its center, so we have to move it to (650/2, 650-50/2)
    objects.border.ground.shape = love.physics.newRectangleShape(windowWidth, border) --make a rectangle with a width of 650 and a height of 25
    objects.border.ground.fixture = love.physics.newFixture(objects.border.ground.body, objects.border.ground.shape) --attach shape to body
    
    objects.border.ceiling = {}
    objects.border.ceiling.body = love.physics.newBody(world, windowWidth/2, border/2)
    objects.border.ceiling.shape = love.physics.newRectangleShape(windowWidth, border) --make a rectangle with a width of 650 and a height of 25
    objects.border.ceiling.fixture = love.physics.newFixture(objects.border.ceiling.body, objects.border.ceiling.shape) --attach shape to body    

    -- Next both walls
    objects.border.leftwall = {}
    objects.border.leftwall.body = love.physics.newBody(world, border/2, windowHeight/2) --remember, the shape (the rectangle we create next) anchors to the body from its center, so we have to move it to (650/2, 650-50/2)
    objects.border.leftwall.shape = love.physics.newRectangleShape(border, windowHeight - 2*border) --make a rectangle with a width of 650 and a height of 25
    objects.border.leftwall.fixture = love.physics.newFixture(objects.border.leftwall.body, objects.border.leftwall.shape) --attach shape to body
    
    objects.border.rightwall = {}
    objects.border.rightwall.body = love.physics.newBody(world, windowWidth-border/2, windowHeight/2)
    objects.border.rightwall.shape = love.physics.newRectangleShape(border, windowHeight - 2*border) --make a rectangle with a width of 650 and a height of 25
    objects.border.rightwall.fixture = love.physics.newFixture(objects.border.rightwall.body, objects.border.rightwall.shape) --attach shape to body
end


-- The player contains several triangles. Each of which includes a color, 
--- physics.shape and area . When we initialize, we give the player just one eq
-- triangle of sizeLength.
function initPlayer()
    local centroidLength = sideLength/(3^(1/2))

    objects.player = {}

    -- Place player in center. Set to "dynamic" so it can move
    local pos_x = windowWidth/2
    local pos_y = windowHeight/2
    objects.player.body = love.physics.newBody(world, pos_x, pos_y, "dynamic")

    -- Add one triangle at center to triangles
    objects.player.triangles = {}
    objects.player.triangles[1] = {}
    objects.player.triangles[1].color = {}
    objects.player.triangles[1].color = {50, 50, 50}

    local ax = 0
    local ay = centroidLength

    local bx = -sideLength/2
    local by = -centroidLength/2

    local cx = sideLength/2
    local cy = -centroidLength/2

    objects.player.triangles[1].shape = love.physics.newPolygonShape(ax, ay, bx, by, cx, cy)
    objects.player.triangles[1].area  = calculateArea(ax, ay, bx, by, cx, cy)

    -- Fix triangle to player with density of 1
    objects.player.fixture = love.physics.newFixture(objects.player.body,
                                                     objects.player.triangles[1].shape, 1)
    objects.player.fixture:setUserData(0)
end

-- An enemy is like a player, except that their location
-- is randomized.
function addEnemy()
    -- Increment which enemy this is
    enemyNum = enemyNum + 1

    local enemy = {}
    local length = sideLength*0.8
    local centroidLength = length/(3^(1/2))

    -- Place enemy randomly on screen
    local pos_x = love.math.random(length, windowWidth - length)
    local pos_y = love.math.random(length, windowHeight - length)
    enemy.body = love.physics.newBody(world, pos_x, pos_y)

    -- Add one triangle at center to triangles
    enemy.triangles = {}
    enemy.triangles[1] = {}
    enemy.triangles[1].color = {}
    enemy.triangles[1].color = {250, 50, 50}

    local ax = 0
    local ay = centroidLength

    local bx = -sideLength/2
    local by = -centroidLength/2

    local cx = sideLength/2
    local cy = -centroidLength/2

    enemy.triangles[1].shape = love.physics.newPolygonShape(ax, ay, bx, by, cx, cy)
    enemy.triangles[1].area  = calculateArea(ax, ay, bx, by, cx, cy)

    -- Fix triangle to enemy with density of 1
    enemy.fixture = love.physics.newFixture(enemy.body,
                                                     enemy.triangles[1].shape, 1)
    
    enemy.fixture:setUserData(enemyNum)
    objects.enemies[enemyNum] = enemy
end

-- Deletes fixtures in remFixtures
-- TODO: The fixture is still drawn on the screen
function cleanUp()
    for i, fixture in ipairs(remFixtures) do
        fixture:destroy()
        table.remove(remFixtures, i)
        addEnemy()
    end

end

function beginContact(a, b, coll)

    a_key = a:getUserData()
    b_key = b:getUserData()

    print(a_key)
    print(b_key)
    -- Find who collided with whom

    -- Create a table for the fixtures to be removed

    if((a_key == 0) and (b_key ~= 0)) then
        local preyArea = (b:getShape()).area
        table.insert(remFixtures, b)
        print(preyArea)
    elseif (a:getUserData() == "player") then

    end
end


 
function endContact(a, b, coll)
 
end
 
function preSolve(a, b, coll)
 
end
 
function postSolve(a, b, coll, normalimpulse, tangentimpulse)
 
end


function calculateArea(ax, ay, bx, by, cx, cy)
    return math.abs((ax*(by - cy) + bx*(cy - ay) + cy*(ay - by))/2)
end


